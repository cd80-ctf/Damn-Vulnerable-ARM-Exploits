# Vulnerability 2: Stack Buffer Overflow in `lightsrv`

The web server at `/usr/bin/lightsrv` is vulnerable to a(nother) stack buffer overflow ([CWE-121](https://cwe.mitre.org/data/definitions/121.html)) in the main request processing loop.

## Impact

The vulnerable webserver runs at root and is accessible over port 8080 in the default configuration.
The vulnerability can be triggered without authentication.
Since stack canaries and ASLR are not enabled, it can be trivially exploited to gain remote code execution.

## Details

The vulnerability exists in `handle_single_request`, which is called whenever the HTTP server receives a new connection.
The pseudocode is as follows:

```c
int handle_single_request(int extSocket)
{
  [...]
  (global) size_t chunkSize = 0;
  (global) char chunk[0x800]
  char* nextChunkPointer;
  char requestBuffer [4100];
  
  nextChunkPointer = requestBuffer;
  while ((chunkSize != 0 || (prevRequestSize = recv(extSocket, chunk, 0x800, 0), 0 < (int)chunkSize))) {
    
    [...read a chunk...]
    
    pvVar2 = memmem(requestBuffer,(int)nextChunkPointer - (int)requestBuffer,"\r\n\r\n",4);
    if (pvVar2 != (void *)0x0) {
      reqAfterNewline = (void *)((int)pvVar2 + 4);
      bufsz = (int)endOfLastChunk - (int)reqAfterNewline;
      
      [...]
      
      pcVar5 = strcasestr(fullRequest,"Content-Length:");
      if (pcVar5 != (char *)0x0) {
        contentSizeStr = [the int after Content-Length]
        size_t contentSize = atoi(contentSizeStr);
        while (0 < (int)contentSize) {
          if (bufsz == 0) {
            bytesRead = recv(ext_socket,reqAfterNewline,contentSize,0);
            if (bytesRead < 1) {
              return 0xffffffff;
            }
            contentSize = contentSize - bytesRead;
            reqAfterNewline = (void *)((int)reqAfterNewline + bytesRead);
          }
          [...]
    }
    
    return handle_req(...);
  }
  return -1;
}
```

Even more abstractly, the processing loop goes like this:
- First, we create a stack buffer of size `0x1000`(ish) to hold the request.
- Next, we read the incoming request in chunks of size `0x800`
- After each chunk, we check to see if the request has the string "\r\n\r\n". If so, we process it as a HTTP request.
**Otherwise, we just keep reading chunks.** (but we covered that in the last writeup)
- If we find "\r\n\r\n", we check for a `Content-Length` header.
- If we then find a `Content-Length` header, and if "\r\n\r\n" was the end of the previous request,
**we receive `Content-Length` many bytes into a fixed-size stack buffer without checking `Content-Length`**.

This allows us to overflow the `requestBuffer` with arbitrary content. Since this function also doesn't have a stack
cookie, this can be trivially abused for code execution.

## Exploitation

Exploitation of this bug is very similar to the previous `lightsrv` overflow. The only tricky part is that we send our
request in two parts: first, the shellcode and the `Content-Length` header; second, the actual payload with the ROP
chain. Said chain is identical to the one in our previous writeup. Refer to that for details. The upshot
is...

### Assuming Direct Control

1) Start the router using EMUX, forwarding the vulnerable port 8080 to 28080.
2) In another tab, open an EMUX terminal and start the listener: `nc -lvp 52608`
3) Run the exploit script: `python main.py`
4) In the listener tab, enter the password `cd80`
5) `cat /etc/shadow`, etc.

## Mitigations

The root cause of this exploit is that the `Content-Length` of the incoming request is not checked. To fix it, the
server should truncate all `Content-Lengths` such that the received data fits in the stack buffer.

Compiling this binary with stack canaries would also neuter this bug, and enabling ASLR would make it much more
frustrating (though, since the service restarts itself, not impossible!) to exploit.
